// Generated by CoffeeScript 1.6.3
/*
# node-make-sync
# Copyright(c) 2012 Seb Vincent
# MIT Licensed
*/


(function() {
  var Fiber, Future, Options, callSync, current, makeFuncSync, makeObjSync, makeSync, sync, wait,
    __slice = [].slice;

  Fiber = require('fibers');

  Future = require('fibers/future');

  wait = Future.wait;

  Options = require('./options').Options;

  callSync = function() {
    var args, f, fWithErr, rawRes, resultBuilderFunc, wrappedf;
    f = arguments[0], resultBuilderFunc = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    fWithErr = function(callback) {
      return f.apply(this, __slice.call(args).concat([function() {
          var res;
          res = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return callback(null, res);
        }]));
    };
    wrappedf = Future.wrap(fWithErr);
    rawRes = wrappedf.apply(this);
    wait(rawRes);
    rawRes = rawRes.get();
    return resultBuilderFunc.apply(this, rawRes);
  };

  makeFuncSync = function(f, options, key) {
    var mode, numOfParams, prepareCall, resultBuilderFunc;
    mode = options.mode();
    numOfParams = options.numOfParams(key);
    prepareCall = [][0];
    switch (mode[0]) {
      case 'sync':
        prepareCall = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return ['sync', args];
        };
        break;
      case 'async':
        prepareCall = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return ['async', args];
        };
        break;
      case 'mixed':
        switch (mode[1]) {
          case 'fibers':
            prepareCall = function() {
              var args;
              args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              if (Fiber.current != null) {
                return ['sync', args];
              } else {
                return ['async', args];
              }
            };
            break;
          case 'args':
            prepareCall = function() {
              var args, done, _i;
              args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), done = arguments[_i++];
              if ((numOfParams != null) && (done != null) && args.length < numOfParams) {
                args.push(done);
                done = void 0;
              }
              if ((done != null) && typeof done !== 'function') {
                args.push(done);
                done = void 0;
              }
              if (done) {
                return ['async', args.concat([done])];
              } else {
                return ['sync', args];
              }
            };
        }
    }
    resultBuilderFunc = options.syncReturn(key);
    return function() {
      var args, callMode, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _ref = prepareCall.apply(null, args), callMode = _ref[0], args = _ref[1];
      switch (callMode) {
        case 'sync':
          return callSync.apply(this, [f, resultBuilderFunc].concat(__slice.call(args)));
        case 'async':
          return f.apply(this, __slice.call(args));
      }
    };
  };

  makeObjSync = function(obj, options) {
    var k, v, vSync;
    for (k in obj) {
      v = obj[k];
      if (typeof v === 'function') {
        if (options.isIncluded(k)) {
          vSync = makeFuncSync(v, options, k);
          obj[k] = vSync;
        }
      }
    }
    return obj;
  };

  makeSync = function(target, _options) {
    var options;
    options = new Options(_options);
    switch (typeof target) {
      case 'function':
        return makeFuncSync(target, options);
      case 'object':
        return makeObjSync(target, options);
    }
  };

  sync = function(f) {
    var fn;
    fn = Fiber(f);
    return fn.run();
  };

  current = function() {
    return Fiber.current;
  };

  exports.Sync = sync;

  exports.MakeSync = makeSync;

  exports.MakeObjSync = makeObjSync;

  exports.MakeFuncSync = makeFuncSync;

  exports.Current = current;

  exports.sync = sync;

  exports.makeSync = makeSync;

  exports.makeObjSync = makeObjSync;

  exports.makeFuncSync = makeFuncSync;

  exports.current = current;

}).call(this);
